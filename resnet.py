# -*- coding: utf-8 -*-
"""resnet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SR218ItZ55RFj3OImPNUwGVi4lDO1Q_K
"""

# ğŸ§  ResNet18 ê¸°ë°˜ Binary Classification (Accuracy + Precision + Recall + F1 ì¶œë ¥)

import os
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
from torchvision.models import resnet18, ResNet18_Weights
from sklearn.metrics import classification_report

# âœ… 1. ê²½ë¡œ & ì¥ì¹˜ ì„¤ì •
data_dir = '/content/drive/MyDrive/split_dataset'  # train/, test/ í¬í•¨ëœ í´ë”
train_dir = os.path.join(data_dir, 'train')
test_dir  = os.path.join(data_dir, 'test')
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# âœ… 2. ì „ì²˜ë¦¬ + ë°ì´í„° ë¡œë”©
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],
                         [0.229, 0.224, 0.225])
])

train_data = datasets.ImageFolder(train_dir, transform=transform)
test_data  = datasets.ImageFolder(test_dir, transform=transform)
train_loader = DataLoader(train_data, batch_size=32, shuffle=True)
test_loader  = DataLoader(test_data, batch_size=32, shuffle=False)

print(f"âœ”ï¸ í•™ìŠµ ë°ì´í„° ìˆ˜: {len(train_data)}, í…ŒìŠ¤íŠ¸ ë°ì´í„° ìˆ˜: {len(test_data)}")
print(f"âœ”ï¸ í´ë˜ìŠ¤ ë§¤í•‘: {train_data.class_to_idx}")  # ì˜ˆ: {'defect': 0, 'no_defect': 1}

# âœ… 3. ëª¨ë¸ ì •ì˜ (ResNet18 + 1 output)
model = resnet18(weights=ResNet18_Weights.DEFAULT)
model.fc = nn.Linear(model.fc.in_features, 1)  # binary classification
model = model.to(device)

criterion = nn.BCEWithLogitsLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=1e-4)

# âœ… 4. í•™ìŠµ í•¨ìˆ˜
def train_one_epoch(model, loader):
    model.train()
    total_loss = 0.0
    correct = 0
    total = 0

    for batch_idx, (images, labels) in enumerate(loader):
        images = images.to(device)
        labels = labels.float().unsqueeze(1).to(device)

        outputs = model(images)
        loss = criterion(outputs, labels)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        preds = (torch.sigmoid(outputs) > 0.5).float()
        correct += (preds == labels).sum().item()
        total += labels.size(0)
        total_loss += loss.item()

    acc = correct / total
    print(f"ğŸ“˜ Train Loss: {total_loss:.4f} | Acc: {acc:.4f}")


# âœ… 5. í‰ê°€ í•¨ìˆ˜ (ì •í™•ë„ + ì •ë°€ë„ + ì¬í˜„ìœ¨ + F1)
def evaluate_metrics(model, loader, tag='Test'):
    model.eval()
    all_preds = []
    all_labels = []

    with torch.no_grad():
        for images, labels in loader:
            images = images.to(device)
            labels = labels.to(device)
            outputs = model(images)
            preds = (torch.sigmoid(outputs) > 0.5).int().squeeze(1)

            all_preds.extend(preds.cpu().numpy())
            all_labels.extend(labels.cpu().numpy())

    print(f"\nğŸ“Š {tag} Classification Report:")
    print(classification_report(all_labels, all_preds, target_names=['defect', 'no_defect']))

# âœ… 6. í•™ìŠµ ë£¨í”„ + í…ŒìŠ¤íŠ¸
for epoch in range(10):
    print(f"\nğŸ” Epoch {epoch+1}")
    train_one_epoch(model, train_loader)
    evaluate_metrics(model, test_loader, tag="Test")

# âœ… 7. ëª¨ë¸ ì €ì¥ (ì„ íƒ)
torch.save(model.state_dict(), '/content/drive/MyDrive/resnet18_base_20.pt')

# ğŸ§  ResNet18 ê¸°ë°˜ Binary Classification (Accuracy + Precision + Recall + F1 ì¶œë ¥)

import os
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
from torchvision.models import resnet18, ResNet18_Weights
from sklearn.metrics import classification_report

# âœ… 1. ê²½ë¡œ & ì¥ì¹˜ ì„¤ì •
data_dir = '/content/drive/MyDrive/split_dataset_aug'  # train/, test/ í¬í•¨ëœ í´ë”
train_dir = os.path.join(data_dir, 'train')
test_dir  = os.path.join(data_dir, 'test')
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# âœ… 2. ì „ì²˜ë¦¬ + ë°ì´í„° ë¡œë”©
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],
                         [0.229, 0.224, 0.225])
])

train_data = datasets.ImageFolder(train_dir, transform=transform)
test_data  = datasets.ImageFolder(test_dir, transform=transform)
train_loader = DataLoader(train_data, batch_size=32, shuffle=True)
test_loader  = DataLoader(test_data, batch_size=32, shuffle=False)

print(f"âœ”ï¸ í•™ìŠµ ë°ì´í„° ìˆ˜: {len(train_data)}, í…ŒìŠ¤íŠ¸ ë°ì´í„° ìˆ˜: {len(test_data)}")
print(f"âœ”ï¸ í´ë˜ìŠ¤ ë§¤í•‘: {train_data.class_to_idx}")  # ì˜ˆ: {'defect': 0, 'no_defect': 1}

# âœ… 3. ëª¨ë¸ ì •ì˜ (ResNet18 + 1 output)
model = resnet18(weights=ResNet18_Weights.DEFAULT)
model.fc = nn.Linear(model.fc.in_features, 1)  # binary classification
model = model.to(device)

criterion = nn.BCEWithLogitsLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=1e-4)

# âœ… 4. í•™ìŠµ í•¨ìˆ˜
def train_one_epoch(model, loader):
    model.train()
    total_loss = 0.0
    correct = 0
    total = 0

    for batch_idx, (images, labels) in enumerate(loader):
        images = images.to(device)
        labels = labels.float().unsqueeze(1).to(device)

        outputs = model(images)
        loss = criterion(outputs, labels)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        preds = (torch.sigmoid(outputs) > 0.5).float()
        correct += (preds == labels).sum().item()
        total += labels.size(0)
        total_loss += loss.item()

    acc = correct / total
    print(f"ğŸ“˜ Train Loss: {total_loss:.4f} | Acc: {acc:.4f}")


# âœ… 5. í‰ê°€ í•¨ìˆ˜ (ì •í™•ë„ + ì •ë°€ë„ + ì¬í˜„ìœ¨ + F1)
def evaluate_metrics(model, loader, tag='Test'):
    model.eval()
    all_preds = []
    all_labels = []

    with torch.no_grad():
        for images, labels in loader:
            images = images.to(device)
            labels = labels.to(device)
            outputs = model(images)
            preds = (torch.sigmoid(outputs) > 0.5).int().squeeze(1)

            all_preds.extend(preds.cpu().numpy())
            all_labels.extend(labels.cpu().numpy())

    print(f"\nğŸ“Š {tag} Classification Report:")
    print(classification_report(all_labels, all_preds, target_names=['defect', 'no_defect']))

# âœ… 6. í•™ìŠµ ë£¨í”„ + í…ŒìŠ¤íŠ¸
for epoch in range(10):
    print(f"\nğŸ” Epoch {epoch+1}")
    train_one_epoch(model, train_loader)
    evaluate_metrics(model, test_loader, tag="Test")

# âœ… 7. ëª¨ë¸ ì €ì¥ (ì„ íƒ)
torch.save(model.state_dict(), '/content/drive/MyDrive/resnet18_aug_20.pt')

import os
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
from torchvision.models import resnet18, ResNet18_Weights
from sklearn.metrics import classification_report

# âœ… 1. ê²½ë¡œ & ì¥ì¹˜ ì„¤ì •
data_dir = '/content/drive/MyDrive/split_dataset'  # train/, test/ í¬í•¨ëœ í´ë”
train_dir = os.path.join(data_dir, 'train')
test_dir  = os.path.join(data_dir, 'test')
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# âœ… 2. ì „ì²˜ë¦¬ + ë°ì´í„° ë¡œë”©
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],
                         [0.229, 0.224, 0.225])
])

#train_data = datasets.ImageFolder(train_dir, transform=transform)
test_data  = datasets.ImageFolder(test_dir, transform=transform)
#train_loader = DataLoader(train_data, batch_size=32, shuffle=True)
test_loader  = DataLoader(test_data, batch_size=32, shuffle=False)

# ëª¨ë¸ ë¡œë“œ
model = resnet18(weights=ResNet18_Weights.DEFAULT)
model.fc = nn.Linear(model.fc.in_features, 1)
model.load_state_dict(torch.load('/content/drive/MyDrive/resnet18_base.pt'))
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = model.to(device)
model.eval()

from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt

y_true = []
y_scores = []

with torch.no_grad():
    for images, labels in test_loader:
        images = images.to(device)
        outputs = model(images)
        probs = torch.sigmoid(outputs).cpu().numpy().flatten()

        y_scores.extend(probs)
        y_true.extend(labels.numpy())

fpr, tpr, thresholds = roc_curve(y_true, y_scores)
roc_auc = auc(fpr, tpr)

plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', linestyle='--')  # ëŒ€ê°ì„  ê¸°ì¤€ì„ 
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve (Test Set)')
plt.legend(loc='lower right')
plt.grid()
plt.show()

import os
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
from torchvision.models import resnet18, ResNet18_Weights
from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt

# âœ… ê²½ë¡œ & ì¥ì¹˜ ì„¤ì •
data_dir = '/content/drive/MyDrive/split_dataset'
test_dir = os.path.join(data_dir, 'test')
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# âœ… ì „ì²˜ë¦¬
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],
                         [0.229, 0.224, 0.225])
])

# âœ… í…ŒìŠ¤íŠ¸ ë°ì´í„° ë¡œë”©
test_data = datasets.ImageFolder(test_dir, transform=transform)
test_loader = DataLoader(test_data, batch_size=32, shuffle=False)

# âœ… ëª¨ë¸ ë¡œë“œ
model = resnet18(weights=ResNet18_Weights.DEFAULT)
model.fc = nn.Linear(model.fc.in_features, 1)
model.load_state_dict(torch.load('/content/drive/MyDrive/resnet18_base.pt'))
model = model.to(device)
model.eval()

# âœ… ROC ê³„ì‚°ìš© ì˜ˆì¸¡ ìˆ˜í–‰ (ì§„í–‰ ìƒí™© ì¶œë ¥)
y_true = []
y_scores = []

print(f"\nğŸš€ ROC Curve ê³„ì‚° ì‹œì‘ (ì´ {len(test_loader)} ë°°ì¹˜)\n")

with torch.no_grad():
    for batch_idx, (images, labels) in enumerate(test_loader):
        print(f"  ğŸ”„ ë°°ì¹˜ {batch_idx + 1}/{len(test_loader)} ì²˜ë¦¬ ì¤‘...")

        images = images.to(device)
        outputs = model(images)
        probs = torch.sigmoid(outputs).cpu().numpy().flatten()

        y_scores.extend(probs)
        y_true.extend(labels.numpy())

# âœ… ROC Curve ë° AUC ê³„ì‚°
fpr, tpr, thresholds = roc_curve(y_true, y_scores)
roc_auc = auc(fpr, tpr)

# âœ… ì‹œê°í™”
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', linestyle='--')  # ëŒ€ê°ì„  ê¸°ì¤€ì„ 
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve (Test Set)')
plt.legend(loc='lower right')
plt.grid()
plt.show()

import os
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
from torchvision.models import resnet18, ResNet18_Weights
from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt

# âœ… ê²½ë¡œ & ì¥ì¹˜ ì„¤ì •
data_dir = '/content/drive/MyDrive/split_dataset'
test_dir = os.path.join(data_dir, 'test')
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# âœ… ì „ì²˜ë¦¬
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],
                         [0.229, 0.224, 0.225])
])

# âœ… í…ŒìŠ¤íŠ¸ ë°ì´í„° ë¡œë”©
test_data = datasets.ImageFolder(test_dir, transform=transform)
test_loader = DataLoader(test_data, batch_size=32, shuffle=False)

# âœ… ëª¨ë¸ ë¡œë“œ
model = resnet18(weights=ResNet18_Weights.DEFAULT)
model.fc = nn.Linear(model.fc.in_features, 1)
model.load_state_dict(torch.load('/content/drive/MyDrive/resnet18_aug.pt'))
model = model.to(device)
model.eval()

# âœ… ROC ê³„ì‚°ìš© ì˜ˆì¸¡ ìˆ˜í–‰ (ì§„í–‰ ìƒí™© ì¶œë ¥)
y_true = []
y_scores = []

print(f"\nğŸš€ ROC Curve ê³„ì‚° ì‹œì‘ (ì´ {len(test_loader)} ë°°ì¹˜)\n")

with torch.no_grad():
    for batch_idx, (images, labels) in enumerate(test_loader):
        print(f"  ğŸ”„ ë°°ì¹˜ {batch_idx + 1}/{len(test_loader)} ì²˜ë¦¬ ì¤‘...")

        images = images.to(device)
        outputs = model(images)
        probs = torch.sigmoid(outputs).cpu().numpy().flatten()

        y_scores.extend(probs)
        y_true.extend(labels.numpy())

# âœ… ROC Curve ë° AUC ê³„ì‚°
fpr, tpr, thresholds = roc_curve(y_true, y_scores)
roc_auc = auc(fpr, tpr)

# âœ… ì‹œê°í™”
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', linestyle='--')  # ëŒ€ê°ì„  ê¸°ì¤€ì„ 
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve (Test Set)')
plt.legend(loc='lower right')
plt.grid()
plt.show()

import os
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
from torchvision.models import resnet18, ResNet18_Weights
from sklearn.metrics import precision_recall_curve, average_precision_score
import matplotlib.pyplot as plt

# âœ… 1. ì¥ì¹˜ ë° ê²½ë¡œ ì„¤ì •
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
data_dir = '/content/drive/MyDrive/split_dataset'
test_dir = os.path.join(data_dir, 'test')
model_path = '/content/drive/MyDrive/resnet18_base.pt'

# âœ… 2. ì „ì²˜ë¦¬ ë° ë°ì´í„° ë¡œë”©
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],
                         [0.229, 0.224, 0.225])
])

test_dataset = datasets.ImageFolder(test_dir, transform=transform)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

# âœ… 3. ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°
model = resnet18(weights=ResNet18_Weights.DEFAULT)
model.fc = nn.Linear(model.fc.in_features, 1)
model.load_state_dict(torch.load(model_path))
model = model.to(device)
model.eval()

# âœ… 4. í…ŒìŠ¤íŠ¸ì…‹ ì˜ˆì¸¡ (í™•ë¥  ë° ì •ë‹µ ìˆ˜ì§‘)
y_true = []
y_scores = []

print(f"\nğŸš€ Precision-Recall Curve ê³„ì‚° ì‹œì‘ (ì´ {len(test_loader)} ë°°ì¹˜)\n")

with torch.no_grad():
    for batch_idx, (images, labels) in enumerate(test_loader):
        print(f"  ğŸ”„ ë°°ì¹˜ {batch_idx + 1}/{len(test_loader)} ì²˜ë¦¬ ì¤‘...")

        images = images.to(device)
        outputs = model(images)
        probs = torch.sigmoid(outputs).cpu().numpy().flatten()

        y_scores.extend(probs)
        y_true.extend(labels.numpy())

# âœ… 5. Precision-Recall Curve ê³„ì‚°
precision, recall, thresholds = precision_recall_curve(y_true, y_scores)
ap_score = average_precision_score(y_true, y_scores)

# âœ… 6. ì‹œê°í™”
plt.figure()
plt.plot(recall, precision, color='green', lw=2, label=f'PR Curve (AP = {ap_score:.2f})')
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall Curve (Base Model)')
plt.legend(loc='lower left')
plt.grid()
plt.show()

import os
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision import datasets, transforms
from torchvision.models import resnet18, ResNet18_Weights
from sklearn.metrics import precision_recall_curve, average_precision_score
import matplotlib.pyplot as plt

# âœ… 1. ì¥ì¹˜ ë° ê²½ë¡œ ì„¤ì •
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
data_dir = '/content/drive/MyDrive/split_dataset'
test_dir = os.path.join(data_dir, 'test')
model_path = '/content/drive/MyDrive/resnet18_aug.pt'

# âœ… 2. ì „ì²˜ë¦¬ ë° ë°ì´í„° ë¡œë”©
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],
                         [0.229, 0.224, 0.225])
])

test_dataset = datasets.ImageFolder(test_dir, transform=transform)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

# âœ… 3. ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°
model = resnet18(weights=ResNet18_Weights.DEFAULT)
model.fc = nn.Linear(model.fc.in_features, 1)
model.load_state_dict(torch.load(model_path))
model = model.to(device)
model.eval()

# âœ… 4. í…ŒìŠ¤íŠ¸ì…‹ ì˜ˆì¸¡ (í™•ë¥  ë° ì •ë‹µ ìˆ˜ì§‘)
y_true = []
y_scores = []

print(f"\nğŸš€ Precision-Recall Curve ê³„ì‚° ì‹œì‘ (ì´ {len(test_loader)} ë°°ì¹˜)\n")

with torch.no_grad():
    for batch_idx, (images, labels) in enumerate(test_loader):
        print(f"  ğŸ”„ ë°°ì¹˜ {batch_idx + 1}/{len(test_loader)} ì²˜ë¦¬ ì¤‘...")

        images = images.to(device)
        outputs = model(images)
        probs = torch.sigmoid(outputs).cpu().numpy().flatten()

        y_scores.extend(probs)
        y_true.extend(labels.numpy())

# âœ… 5. Precision-Recall Curve ê³„ì‚°
precision, recall, thresholds = precision_recall_curve(y_true, y_scores)
ap_score = average_precision_score(y_true, y_scores)

# âœ… 6. ì‹œê°í™”
plt.figure()
plt.plot(recall, precision, color='green', lw=2, label=f'PR Curve (AP = {ap_score:.2f})')
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall Curve (Augmented Model)')
plt.legend(loc='lower left')
plt.grid()
plt.show()